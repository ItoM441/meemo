<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>階層メモ帳</title>

  <!-- ▼ スマホ自動同期用：Gistのユーザー名とIDを設定してください ▼ -->
  <meta name="x-default-gist-user" content="ItoM441">
  <meta name="x-default-gist-id" content="YOUR_GIST_ID_HERE">
  <!-- ▲ ここを書き換えるだけで、スマホは開くだけで自動読み込みします ▲ -->

  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body{margin:0;padding:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto",sans-serif}
    .drop-hint{height:4px;border-radius:9999px}
    input, textarea { font-size: 16px; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    /* ===== Icons ===== */
    const ChevronDown = ({ size=24 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M6 9l6 6 6-6"/></svg>);
    const ChevronRight= ({ size=24 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M9 18l6-6-6-6"/></svg>);
    const Folder      = ({ size=24, className="" }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className={className}><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>);
    const FileText    = ({ size=24, className="" }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className={className}><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><path d="M14 2v6h6M16 13H8M16 17H8M10 9H8"/></svg>);
    const Plus        = ({ size=24 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M12 5v14M5 12h14"/></svg>);
    const Edit2       = ({ size=24 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>);
    const Trash2      = ({ size=24 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>);
    const SaveIcon    = ({ size=24 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17,21 17,13 7,13 7,21"/><polyline points="7,3 7,8 15,8"/></svg>);
    const X           = ({ size=24 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M18 6L6 18M6 6l12 12"/></svg>);
    const TableIcon   = ({ size=24 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg>);
    const Grip        = ({ size=18 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="currentColor"><circle cx="7" cy="6" r="1.5"/><circle cx="12" cy="6" r="1.5"/><circle cx="17" cy="6" r="1.5"/><circle cx="7" cy="12" r="1.5"/><circle cx="12" cy="12" r="1.5"/><circle cx="17" cy="12" r="1.5"/><circle cx="7" cy="18" r="1.5"/><circle cx="12" cy="18" r="1.5"/><circle cx="17" cy="18" r="1.5"/></svg>);

    /* ===== Utils & Keys ===== */
    const clone = (o) => JSON.parse(JSON.stringify(o));
    const STORAGE_KEY   = 'hn_items_v3';
    const GIST_TOKEN_KEY= 'hn_gist_token';
    const GIST_ID_KEY   = 'hn_gist_id';
    const AUTO_PUSH_KEY = 'hn_gist_auto_push';

    const sampleItems = () => ([
      { id: '1', type: 'folder', name: 'プロジェクト', expanded: true,
        children: [
          { id: '2', type: 'note', name: 'アイデア', content: 'ここにメモの内容を書きます...', blocks: [] },
          { id: '3', type: 'folder', name: '設計', expanded: false,
            children: [{ id: '4', type: 'note', name: 'UI設計', content: 'UIの検討事項', blocks: [] }] }
        ]},
      { id: '5', type: 'note', name: '日記', content: '今日は良い一日でした。', blocks: [] }
    ]);

    function migrateItems(items) {
      const walk = (arr) => arr.map(it => {
        if (it.type === 'note') return { ...it, blocks: Array.isArray(it.blocks)?it.blocks:[], content: typeof it.content==='string'?it.content:'' };
        if (it.children) return { ...it, children: walk(it.children) };
        return it;
      });
      return walk(items);
    }

    function findPathById(items, id, path = []) {
      for (let i = 0; i < items.length; i++) {
        const it = items[i];
        if (it.id === id) return [...path, i];
        if (it.type === 'folder' && Array.isArray(it.children) && it.children.length) {
          const p = findPathById(it.children, id, [...path, i, 'children']);
          if (p) return p;
        }
      }
      return null;
    }
    function getArrayFromParentPath(rootClone, parentPath) {
      let arr = rootClone, obj = null;
      for (const token of parentPath) {
        if (token === 'children') {
          if (!obj) throw new Error('Invalid path: children without object');
          if (!Array.isArray(obj.children)) obj.children = [];
          arr = obj.children; obj = null;
        } else {
          obj = arr[token];
          if (!obj) throw new Error('Invalid path index');
        }
      }
      return arr;
    }
    function removeByPath(items, fullPath) {
      const cloned = clone(items);
      const parentPath = fullPath.slice(0, -1);
      const index = fullPath[fullPath.length - 1];
      const parentArr = getArrayFromParentPath(cloned, parentPath);
      const removed = parentArr.splice(index, 1)[0];
      return { newItems: cloned, removed };
    }
    function insertIntoParentPath(items, parentPath, index, node) {
      const cloned = clone(items);
      const targetArr = getArrayFromParentPath(cloned, parentPath);
      const safeIndex = Math.max(0, Math.min(targetArr.length, index));
      targetArr.splice(safeIndex, 0, node);
      return cloned;
    }
    function getParentPathAndIndex(path) {
      return { parentPath: path.slice(0, -1), index: path[path.length - 1] };
    }
    const newId = (p='id') => `${p}-${Date.now()}-${Math.random().toString(36).slice(2,7)}`;

    /* ===== GitHub Gist API helpers ===== */
    const GH_API = 'https://api.github.com';

    async function ghFetch(token, path, method='GET', body=null, scheme='token') {
      const headers = {
        'Accept':'application/vnd.github+json',
        'X-GitHub-Api-Version':'2022-11-28',
        'Authorization': `${scheme} ${token}`
      };
      const res = await fetch(`${GH_API}${path}`, { method, headers, body: body ? JSON.stringify(body) : null });
      if (res.status === 401 && scheme === 'token') {
        // 401 の場合は Bearer でもう一度（fine-grained 対応）
        return ghFetch(token, path, method, body, 'Bearer');
      }
      if (!res.ok) {
        const text = await res.text().catch(()=> '');
        throw new Error(`GitHub API ${res.status}: ${text||res.statusText}`);
      }
      return res.json();
    }

    async function gistCreate(token, items) {
      const body = {
        description: 'Hierarchical Notepad data (notes.json)',
        public: false,
        files: { 'notes.json': { content: JSON.stringify(items, null, 2) } }
      };
      const json = await ghFetch(token, '/gists', 'POST', body);
      return json.id;
    }
    async function gistUpdate(token, gistId, items) {
      const body = { files: { 'notes.json': { content: JSON.stringify(items, null, 2) } } };
      await ghFetch(token, `/gists/${gistId}`, 'PATCH', body);
    }
    async function gistFetch(token, gistId) {
      const json = await ghFetch(token, `/gists/${gistId}`, 'GET');
      const file = json.files?.['notes.json'];
      if (!file) throw new Error('notes.json が見つかりません。');
      if (file.truncated && file.raw_url) {
        const raw = await fetch(file.raw_url, { cache:'no-store' }).then(r=>r.text());
        return JSON.parse(raw);
      }
      if (typeof file.content === 'string') return JSON.parse(file.content);
      if (file.raw_url) {
        const raw = await fetch(file.raw_url, { cache:'no-store' }).then(r=>r.text());
        return JSON.parse(raw);
      }
      throw new Error('Gist の内容を取得できませんでした。');
    }

    /* ▼ 追加：トークン不要の Raw 取得（読み取り専用） ▼ */
    function buildRawUrl(user, gistId, filename='notes.json') {
      return `https://gist.githubusercontent.com/${encodeURIComponent(user)}/${encodeURIComponent(gistId)}/raw/${encodeURIComponent(filename)}`;
    }
    async function gistFetchRawUnauthed(user, gistId) {
      const url = buildRawUrl(user, gistId, 'notes.json');
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Raw fetch ${res.status}`);
      const text = await res.text();
      return JSON.parse(text);
    }
    /* ▲ 追加ここまで ▲ */

    /* ===== App ===== */
    const HierarchicalNotepad = () => {
      // localStorage → 既存 or サンプル
      const [items, setItems] = React.useState(() => {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (raw) { const data = JSON.parse(raw); if (Array.isArray(data)) return migrateItems(data); }
        } catch {}
        return sampleItems();
      });

      const [selectedItem, setSelectedItem] = React.useState(null);
      const [editingItem, setEditingItem] = React.useState(null);
      const [editValue, setEditValue] = React.useState('');
      const [draggedId, setDraggedId] = React.useState(null);
      const [dropHint, setDropHint] = React.useState(null);
      const [highlightFolderId, setHighlightFolderId] = React.useState(null);
      const [isMobileMenuOpen, setIsMobileMenuOpen] = React.useState(false);

      // 保存UI
      const [saving, setSaving] = React.useState(false);
      const [lastSavedAt, setLastSavedAt] = React.useState(null);
      const saveTimerRef = React.useRef(null);

      // Gist 同期状態
      const [gistToken, setGistToken] = React.useState(() => localStorage.getItem(GIST_TOKEN_KEY) || '');
      const [gistId, setGistId]       = React.useState(() => localStorage.getItem(GIST_ID_KEY) || '');
      const [autoPush, setAutoPush]   = React.useState(() => localStorage.getItem(AUTO_PUSH_KEY) === '1');
      const [syncOpen, setSyncOpen]   = React.useState(false);
      const [syncMsg, setSyncMsg]     = React.useState('');

      /* ▼ 追加：スマホでも開くだけで自動同期（読み取り専用モード） ▼
         - URL ?gist=...&user=... があればそれを優先
         - なければ <meta name="x-default-gist-user/id"> を使う
         - トークンが未設定のときだけ有効（＝スマホ側） */
      const urlParams = new URLSearchParams(window.location.search);
      const qsGist = urlParams.get('gist') || '';
      const qsUser = urlParams.get('user') || '';
      const metaUser = document.querySelector('meta[name="x-default-gist-user"]')?.content || '';
      const metaId   = document.querySelector('meta[name="x-default-gist-id"]')?.content || '';
      const roUser = qsUser || metaUser;
      const roGist = qsGist || metaId;
      const readOnlyMode = (!gistToken) && !!roUser && !!roGist;

      const [lastPulledAt, setLastPulledAt] = React.useState(null);
      React.useEffect(() => {
        if (!readOnlyMode) return;
        let stop = false;
        const pull = async () => {
          try {
            const data = await gistFetchRawUnauthed(roUser, roGist);
            if (Array.isArray(data)) {
              setItems(migrateItems(data));
              setSelectedItem(null);
              setLastPulledAt(Date.now());
              try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); } catch {}
            }
          } catch (e) {
            console.warn('自動Pull失敗:', e.message);
          }
        };
        pull(); // 初回
        const t = setInterval(() => { if (!stop) pull(); }, 8000); // 8秒毎
        return () => { stop = true; clearInterval(t); };
      }, [readOnlyMode, roUser, roGist]);
      /* ▲ 追加ここまで ▲ */

      // 自動保存（ローカル）
      React.useEffect(() => {
        setSaving(true);
        if (saveTimerRef.current) clearTimeout(saveTimerRef.current);
        saveTimerRef.current = setTimeout(() => {
          try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(items));
            setLastSavedAt(Date.now());
          } catch (e) { console.error('保存失敗: ', e); }
          setSaving(false);
        }, 300);
        return () => clearTimeout(saveTimerRef.current);
      }, [items]);

      // 画面外誤ドロップ防止
      React.useEffect(() => {
        const prevent = e => e.preventDefault();
        window.addEventListener('dragover', prevent);
        window.addEventListener('drop', prevent);
        return () => { window.removeEventListener('dragover', prevent); window.removeEventListener('drop', prevent); };
      }, []);

      // オートPush（節約のため 2 秒デバウンス）
      const autoPushTimer = React.useRef(null);
      React.useEffect(() => {
        if (!autoPush || !gistToken || !gistId) return;
        if (autoPushTimer.current) clearTimeout(autoPushTimer.current);
        autoPushTimer.current = setTimeout(async () => {
          try {
            await gistUpdate(gistToken, gistId, items);
            setSyncMsg('Gistへ自動保存しました');
            setTimeout(()=> setSyncMsg(''), 1500);
          } catch (e) {
            setSyncMsg('自動保存に失敗: ' + e.message);
            setTimeout(()=> setSyncMsg(''), 2500);
          }
        }, 2000);
        return () => clearTimeout(autoPushTimer.current);
      }, [items, autoPush, gistToken, gistId]);

      /* ===== Note helpers ===== */
      const updateNoteById = (noteId, updater) => {
        const walk = (arr) => arr.map(it => {
          if (it.id === noteId && it.type === 'note') return updater({ ...it, blocks: it.blocks || [] });
          if (it.children) return { ...it, children: walk(it.children) };
          return it;
        });
        setItems(prev => walk(prev));
        setSelectedItem(prev => {
          if (!prev || prev.id !== noteId || prev.type !== 'note') return prev;
          return updater({ ...prev, blocks: prev.blocks || [] });
        });
      };

      /* ===== CRUD ===== */
      const removeItem = (arr, id) => arr.filter(it => {
        if (it.id === id) return false;
        if (it.children) it.children = removeItem(it.children, id);
        return true;
      });
      const addItemToParent = (arr, parentId, newItem) => arr.map(it => {
        if (it.id === parentId && it.type === 'folder') return { ...it, children: [ ...(it.children || []), newItem ] };
        if (it.children) return { ...it, children: addItemToParent(it.children, parentId, newItem) };
        return it;
      });

      const handleToggleExpand = (id) => {
        const walk = a => a.map(it => {
          if (it.id === id) return { ...it, expanded: !it.expanded };
          if (it.children) return { ...it, children: walk(it.children) };
          return it;
        });
        setItems(walk(items));
      };

      const handleSelectItem = (item) => {
        setSelectedItem(item.type === 'note' ? { ...item, blocks: item.blocks || [] } : item);
        setEditingItem(null);
        if (window.innerWidth < 768) setIsMobileMenuOpen(false);
      };

      const handleStartEdit = (item, e) => {
        e.stopPropagation();
        if (readOnlyMode) return;
        setEditingItem(item.id);
        setEditValue(item.name);
      };

      const handleSaveEdit = () => {
        const walk = a => a.map(it => {
          if (it.id === editingItem) return { ...it, name: editValue };
          if (it.children) return { ...it, children: walk(it.children) };
          return it;
        });
        setItems(walk(items));
        setEditingItem(null);
        setEditValue('');
      };
      const handleCancelEdit = () => { setEditingItem(null); setEditValue(''); };

      const handleDeleteItem = (id, e) => {
        e?.stopPropagation?.();
        if (readOnlyMode) return;
        setItems(removeItem(items, id));
        if (selectedItem?.id === id) setSelectedItem(null);
      };

      const handleAddItem = (parentId, type) => {
        if (readOnlyMode) return;
        const newItem = {
          id: Date.now().toString(),
          type,
          name: type === 'folder' ? '新しいフォルダ' : '新しいメモ',
          ...(type === 'folder' ? { expanded: true, children: [] } : { content: '', blocks: [] })
        };
        if (parentId) setItems(addItemToParent(items, parentId, newItem));
        else setItems([ newItem, ...items ]);
      };

      /* ===== Note content auto-resize ===== */
      const noteTextareaRef = React.useRef(null);
      const autoResize = el => { if (!el) return; el.style.height = 'auto'; el.style.height = (el.scrollHeight) + 'px'; };
      React.useEffect(() => { autoResize(noteTextareaRef.current); }, [selectedItem?.id]);
      const handleContentChange = (content) => {
        if (!selectedItem || selectedItem.type !== 'note' || readOnlyMode) return;
        updateNoteById(selectedItem.id, (note) => ({ ...note, content }));
        requestAnimationFrame(()=> autoResize(noteTextareaRef.current));
      };

      /* ===== Table Blocks ===== */
      const addTableBlock = (rows=3, cols=3) => {
        if (!selectedItem || selectedItem.type !== 'note' || readOnlyMode) return;
        const data = Array.from({length: rows}, () => Array.from({length: cols}, () => ''));
        const block = { id: newId('tbl'), type: 'table', rows, cols, data, title: 'テーブル' };
        updateNoteById(selectedItem.id, (note) => ({ ...note, blocks: [...(note.blocks||[]), block] }));
      };
      const updateCell = (blockId, r, c, value) => {
        if (readOnlyMode) return;
        updateNoteById(selectedItem.id, (note) => {
          const blocks = (note.blocks||[]).map(b => {
            if (b.id !== blockId) return b;
            const data = b.data.map((row, ri) => row.map((cell, ci) => (ri===r && ci===c ? value : cell)));
            return { ...b, data };
          });
          return { ...note, blocks };
        });
      };
      const addRow = (blockId) => {
        if (readOnlyMode) return;
        updateNoteById(selectedItem.id, (note) => {
          const blocks = (note.blocks||[]).map(b => b.id!==blockId ? b : ({ ...b, data:[...b.data, Array.from({length:b.cols},()=> '')], rows:b.rows+1 }));
          return { ...note, blocks };
        });
      };
      const addCol = (blockId) => {
        if (readOnlyMode) return;
        updateNoteById(selectedItem.id, (note) => {
          const blocks = (note.blocks||[]).map(b => {
            if (b.id!==blockId) return b;
            return { ...b, data: b.data.map(row=>[...row,'']), cols:b.cols+1 };
          });
          return { ...note, blocks };
        });
      };
      const deleteBlock = (blockId) => {
        if (readOnlyMode) return;
        updateNoteById(selectedItem.id, (note) => ({ ...note, blocks: (note.blocks||[]).filter(b => b.id!==blockId) }));
      };
      const renameBlock = (blockId, title) => {
        if (readOnlyMode) return;
        updateNoteById(selectedItem.id, (note) => ({ ...note, blocks: (note.blocks||[]).map(b => b.id===blockId?{...b,title}:b) }));
      };

      /* ===== Reorder/Move (DnD) ===== */
      const moveDraggedTo = (sourceId, targetId, mode/* 'before'|'after'|'into' */) => {
        if (readOnlyMode) return;
        const srcPath = findPathById(items, sourceId); if (!srcPath) return;
        const { newItems, removed } = removeByPath(items, srcPath);

        if (mode === 'into') {
          const tgtPath = findPathById(newItems, targetId); if (!tgtPath) { setItems(newItems); return; }
          const inserted = insertIntoParentPath(newItems, [...tgtPath, 'children'], Number.MAX_SAFE_INTEGER, removed);
          setItems(inserted);
          return;
        }

        const tgtPath = findPathById(newItems, targetId); if (!tgtPath) { setItems(newItems); return; }
        const { parentPath: tgtParentPath, index: tgtIndex } = getParentPathAndIndex(tgtPath);
        const srcParentPathJSON = JSON.stringify(srcPath.slice(0, -1));
        const tgtParentPathJSON = JSON.stringify(tgtParentPath);
        let insertIndex = (mode === 'before') ? tgtIndex : tgtIndex + 1;
        const sameParent = srcParentPathJSON === tgtParentPathJSON;
        const srcIndex = srcPath[srcPath.length - 1];
        if (sameParent && srcIndex < tgtIndex && mode === 'after') insertIndex -= 1;

        const inserted = insertIntoParentPath(newItems, tgtParentPath, insertIndex, removed);
        setItems(inserted);
      };

      const computeDropPosition = (e, targetEl, targetItem) => {
        const rect = targetEl.getBoundingClientRect();
        const y = e.clientY;
        const topZone = rect.top + rect.height * 0.30;
        const bottomZone = rect.bottom - rect.height * 0.30;
        if (targetItem.type === 'folder' && y >= topZone && y <= bottomZone) return 'into';
        return (y < rect.top + rect.height/2) ? 'before' : 'after';
      };

      const handleDragStart = (e, item) => {
        if (readOnlyMode) return;
        setDraggedId(item.id);
        setHighlightFolderId(null);
        try { e.dataTransfer.setData('text/plain', item.id); } catch {}
        e.dataTransfer.effectAllowed = 'move';
        if (e.currentTarget && e.dataTransfer.setDragImage) {
          e.dataTransfer.setDragImage(e.currentTarget, 10, 10);
        }
      };
      const handleDragOverItem = (e, item) => {
        e.preventDefault(); e.stopPropagation();
        if (readOnlyMode) return;
        if (!draggedId || draggedId === item.id) return;
        const pos = computeDropPosition(e, e.currentTarget, item);
        if (pos === 'into') {
          setHighlightFolderId(item.id); setDropHint(null);
        } else {
          setHighlightFolderId(null); setDropHint({ targetId: item.id, pos });
        }
        e.dataTransfer.dropEffect = 'move';
      };
      const handleDropOnItem = (e, targetItem) => {
        e.preventDefault(); e.stopPropagation();
        if (readOnlyMode) return;
        const sourceId = draggedId; setDraggedId(null);
        if (!sourceId || sourceId === targetItem.id) { setDropHint(null); setHighlightFolderId(null); return; }
        const pos = computeDropPosition(e, e.currentTarget, targetItem);
        moveDraggedTo(sourceId, targetItem.id, pos);
        setDropHint(null); setHighlightFolderId(null);
      };
      const handleRootDrop = (e) => {
        e.preventDefault();
        if (readOnlyMode) return;
        const sourceId = draggedId; setDraggedId(null);
        if (!sourceId) return;
        const srcPath = findPathById(items, sourceId); if (!srcPath) return;
        const { newItems, removed } = removeByPath(items, srcPath);
        const inserted = insertIntoParentPath(newItems, [], 0, removed);
        setItems(inserted); setDropHint(null); setHighlightFolderId(null);
      };

      /* ===== Touch DnD (mobile handle) ===== */
      const startTouchDrag = (e, item) => {
        if (readOnlyMode) return;
        e.preventDefault();
        setDraggedId(item.id);
        const onMove = (ev) => {
          const t = ev.touches ? ev.touches[0] : ev;
          const el = document.elementFromPoint(t.clientX, t.clientY);
          if (!el) return;
          let node = el; while (node && !node.dataset?.treeId) node = node.parentElement;
          if (!node || !node.dataset?.treeId) { setDropHint(null); setHighlightFolderId(null); return; }
          const targetId = node.dataset.treeId;
          if (targetId === item.id) { setDropHint(null); setHighlightFolderId(null); return; }
          const rect = node.getBoundingClientRect();
          const y = t.clientY, topZone = rect.top + rect.height*0.30, bottomZone = rect.bottom - rect.height*0.30;
          const targetType = node.dataset.treeType;
          if (targetType === 'folder' && y >= topZone && y <= bottomZone) { setHighlightFolderId(targetId); setDropHint(null); }
          else { setHighlightFolderId(null); setDropHint({ targetId, pos: (y < rect.top + rect.height/2) ? 'before':'after' }); }
          ev.preventDefault();
        };
        const onEnd = () => {
          if (highlightFolderId) moveDraggedTo(item.id, highlightFolderId, 'into');
          else if (dropHint?.targetId && dropHint?.pos) moveDraggedTo(item.id, dropHint.targetId, dropHint.pos);
          setDropHint(null); setHighlightFolderId(null); setDraggedId(null);
          window.removeEventListener('touchmove', onMove, { passive:false });
          window.removeEventListener('touchend', onEnd);
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onEnd);
        };
        window.addEventListener('touchmove', onMove, { passive:false });
        window.addEventListener('touchend', onEnd);
        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onEnd);
      };

      /* ===== Export / Import / Reset ===== */
      const fileInputRef = React.useRef(null);
      const handleExport = () => {
        const blob = new Blob([JSON.stringify(items, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'notepad-data.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      };
      const handleImportClick = () => fileInputRef.current?.click();
      const handleImportFile = (e) => {
        const file = e.target.files?.[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const data = JSON.parse(reader.result);
            if (!Array.isArray(data)) throw new Error('JSONの形式が違います（配列ではありません）');
            setItems(migrateItems(data)); setSelectedItem(null);
          } catch (err) { alert('読み込みに失敗しました: ' + err.message); }
          finally { e.target.value=''; }
        };
        reader.readAsText(file, 'utf-8');
      };
      const handleReset = () => {
        if (!confirm('すべてのローカル保存を消して初期状態に戻します。よろしいですか？')) return;
        localStorage.removeItem(STORAGE_KEY);
        setItems(sampleItems());
        setSelectedItem(null);
      };

      /* ===== Gist UI handlers（PC編集用） ===== */
      const saveToken = () => {
        if (!gistToken) { alert('トークンを入力してください'); return; }
        localStorage.setItem(GIST_TOKEN_KEY, gistToken);
        setSyncMsg('トークンを保存しました');
        setTimeout(()=> setSyncMsg(''), 1500);
      };
      const clearToken = () => {
        localStorage.removeItem(GIST_TOKEN_KEY);
        setGistToken(''); setSyncMsg('トークンを削除しました'); setTimeout(()=> setSyncMsg(''), 1500);
      };
      const linkGistId = (id) => {
        if (!id) { alert('Gist ID を入力してください'); return; }
        localStorage.setItem(GIST_ID_KEY, id);
        setGistId(id); setSyncMsg('Gist をリンクしました'); setTimeout(()=> setSyncMsg(''), 1500);
      };
      const unlinkGist = () => {
        localStorage.removeItem(GIST_ID_KEY);
        setGistId(''); setSyncMsg('Gist リンクを解除しました'); setTimeout(()=> setSyncMsg(''), 1500);
      };
      const doCreateGist = async () => {
        if (!gistToken) { alert('トークンが必要です'); return; }
        try {
          const id = await gistCreate(gistToken, items);
          localStorage.setItem(GIST_ID_KEY, id);
          setGistId(id);
          setSyncMsg('新規Gistを作成しました');
          setTimeout(()=> setSyncMsg(''), 1500);
        } catch (e) {
          alert('Gist作成に失敗: ' + e.message);
        }
      };
      const doPush = async () => {
        if (!gistToken || !gistId) { alert('トークンとGist IDが必要です'); return; }
        try {
          await gistUpdate(gistToken, gistId, items);
          setSyncMsg('Gistへ保存しました');
          setTimeout(()=> setSyncMsg(''), 1500);
        } catch (e) {
          alert('保存に失敗: ' + e.message);
        }
      };
      const doPull = async () => {
        if (!gistToken || !gistId) { alert('トークンとGist IDが必要です'); return; }
        if (!confirm('Gistの内容で現在のメモを上書きします。よろしいですか？')) return;
        try {
          const data = await gistFetch(gistToken, gistId);
          if (!Array.isArray(data)) throw new Error('Gist内の JSON が配列ではありません');
          setItems(migrateItems(data)); setSelectedItem(null);
          setSyncMsg('Gistから読み込みました');
          setTimeout(()=> setSyncMsg(''), 1500);
        } catch (e) {
          alert('読み込みに失敗: ' + e.message);
        }
      };
      const toggleAutoPush = () => {
        const next = !autoPush; setAutoPush(next);
        localStorage.setItem(AUTO_PUSH_KEY, next ? '1' : '0');
        setSyncMsg(next ? '自動Pushを有効化' : '自動Pushを無効化');
        setTimeout(()=> setSyncMsg(''), 1200);
      };

      /* ===== Table Block ===== */
      const TableBlock = ({ block }) => {
        const [title, setTitle] = React.useState(block.title || 'テーブル');
        React.useEffect(() => { setTitle(block.title || 'テーブル'); }, [block.id, block.title]);
        return (
          <div className="mb-4 border rounded-xl overflow-hidden bg-white shadow-sm">
            <div className="flex items-center justify-between px-3 py-2 bg-gray-50 border-b">
              <div className="flex items-center gap-2">
                <TableIcon size={18}/>
                <input className="px-2 py-1 border rounded w-56 text-sm" value={title}
                  onChange={(e)=>!readOnlyMode && setTitle(e.target.value)}
                  onBlur={()=>!readOnlyMode && renameBlock(block.id, title)} placeholder="テーブル名" disabled={readOnlyMode}/>
              </div>
              <div className="flex items-center gap-2">
                <button onClick={()=>addRow(block.id)} className="px-2 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50" disabled={readOnlyMode}>行を追加</button>
                <button onClick={()=>addCol(block.id)} className="px-2 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50" disabled={readOnlyMode}>列を追加</button>
                <button onClick={()=>deleteBlock(block.id)} className="px-2 py-1 text-sm bg-red-600 text-white rounded hover:bg-red-700 disabled:opacity-50" disabled={readOnlyMode}>削除</button>
              </div>
            </div>
            <div className="overflow-auto">
              <table className="min-w-full table-fixed border-collapse">
                <tbody>
                  {block.data.map((row, ri) => (
                    <tr key={ri}>
                      {row.map((cell, ci) => (
                        <td key={ci} className="border p-0 align-top">
                          <input className="w-full p-2 outline-none"
                            value={cell}
                            onChange={(e)=>updateCell(block.id, ri, ci, e.target.value)}
                            placeholder={`R${ri+1}C${ci+1}`}
                            disabled={readOnlyMode}/>
                        </td>
                      ))}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        );
      };

      /* ===== Sidebar item render ===== */
      const renderTreeItem = (item, depth=0) => {
        const isEditing = editingItem === item.id;
        const isDragged = draggedId === item.id;
        const isHighlightedFolder = item.type === 'folder' && highlightFolderId === item.id;
        const hintBefore = dropHint?.targetId === item.id && dropHint?.pos === 'before';
        const hintAfter  = dropHint?.targetId === item.id && dropHint?.pos === 'after';

        return (
          <div key={item.id}>
            {hintBefore && !readOnlyMode && <div className="drop-hint bg-blue-500 mx-1" style={{marginLeft:`${depth*16+8}px`}}/>}

            <div
              data-tree-id={item.id}
              data-tree-type={item.type}
              className={`flex items-center py-2 px-2 rounded cursor-pointer select-none transition-colors
                ${selectedItem?.id === item.id ? 'bg-blue-100' : isHighlightedFolder ? 'bg-yellow-100 ring-2 ring-yellow-300' : 'hover:bg-gray-100'}
                ${isDragged ? 'opacity-50' : ''}`}
              style={{ marginLeft: `${depth * 16}px`, touchAction: 'manipulation' }}
              onClick={() => handleSelectItem(item)}
              draggable={!isEditing && !readOnlyMode}
              onDragStart={(e)=>handleDragStart(e,item)}
              onDragEnter={(e)=>handleDragOverItem(e,item)}
              onDragOver={(e)=>handleDragOverItem(e,item)}
              onDrop={(e)=>handleDropOnItem(e,item)}
            >
              {item.type === 'folder' && (
                <button onClick={(e)=>{e.stopPropagation();handleToggleExpand(item.id);}}
                        className="mr-1 p-1 hover:bg-gray-200 rounded">
                  {item.expanded ? <ChevronDown size={16}/> : <ChevronRight size={16}/>}
                </button>
              )}

              <div className="mr-2 flex-shrink-0">
                {item.type === 'folder'
                  ? <Folder size={16} className={isHighlightedFolder ? "text-yellow-600" : "text-blue-600"} />
                  : <FileText size={16} className="text-gray-600" />
                }
              </div>

              {isEditing ? (
                <div className="flex items-center flex-1">
                  <input
                    value={editValue}
                    onChange={(e)=>setEditValue(e.target.value)}
                    onKeyDown={(e)=>{ if(e.key==='Enter') handleSaveEdit(); if(e.key==='Escape') handleCancelEdit(); }}
                    className="flex-1 px-2 py-1 border border-blue-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                    autoFocus
                  />
                  <button onClick={handleSaveEdit} className="ml-2 p-1 text-green-600 hover:bg-green-100 rounded"><SaveIcon size={14}/></button>
                  <button onClick={handleCancelEdit} className="ml-1 p-1 text-red-600 hover:bg-red-100 rounded"><X size={14}/></button>
                </div>
              ) : (
                <>
                  <span className="flex-1 text-sm">{item.name}</span>

                  {/* アクション（読み取り専用では非表示） */}
                  {!readOnlyMode && (
                    <div className="flex items-center space-x-1">
                      <button className="p-1 text-gray-600 hover:bg-gray-100 rounded md:hidden" title="ドラッグして並べ替え" onTouchStart={(e)=>startTouchDrag(e, item)}><Grip /></button>
                      <button onClick={(e)=>handleStartEdit(item,e)} className="p-1 text-blue-600 hover:bg-blue-100 rounded" title="名前を編集"><Edit2 size={12}/></button>
                      {item.type === 'folder' && (
                        <>
                          <button onClick={(e)=>{e.stopPropagation();handleAddItem(item.id,'folder');}}
                                  className="p-1 text-blue-600 hover:bg-blue-100 rounded" title="フォルダを追加"><Folder size={12}/></button>
                          <button onClick={(e)=>{e.stopPropagation();handleAddItem(item.id,'note');}}
                                  className="p-1 text-green-600 hover:bg-green-100 rounded" title="メモを追加"><FileText size={12}/></button>
                        </>
                      )}
                      <button onClick={(e)=>handleDeleteItem(item.id,e)} className="p-1 text-red-600 hover:bg-red-100 rounded" title="削除"><Trash2 size={12}/></button>
                    </div>
                  )}
                </>
              )}
            </div>

            {hintAfter && !readOnlyMode && <div className="drop-hint bg-blue-500 mx-1" style={{marginLeft:`${depth*16+8}px`}}/>}

            {item.type === 'folder' && item.expanded && item.children && (
              <div>{item.children.map(ch => renderTreeItem(ch, depth+1))}</div>
            )}
          </div>
        );
      };

      /* ===== Layout ===== */
      return (
        <div className="flex h-screen bg-gray-50 relative">
          {/* 読み取り専用バナー */}
          {readOnlyMode && (
            <div className="fixed top-2 inset-x-2 z-40 flex items-center justify-center">
              <div className="px-3 py-2 rounded-full text-xs bg-amber-100 text-amber-800 border border-amber-300 shadow">
                閲覧モード：Gist（{roUser}/{roGist.slice(0,7)}…）から自動読込中 {lastPulledAt ? `（更新: ${new Date(lastPulledAt).toLocaleTimeString()}）` : ''}
              </div>
            </div>
          )}

          {/* Mobile overlay */}
          {isMobileMenuOpen && <div className="fixed inset-0 bg-black bg-opacity-50 z-10 md:hidden" onClick={()=>setIsMobileMenuOpen(false)}/>}

          {/* Sidebar */}
          <div className={`${isMobileMenuOpen ? 'translate-x-0' : '-translate-x-full'}
              fixed inset-y-0 left-0 z-20 w-80 bg-white border-r border-gray-200 flex flex-col transform transition-transform duration-300 ease-in-out md:relative md:translate-x-0 md:w-1/3`}>
            <div className="p-4 border-b border-gray-200">
              <div className="flex items-center justify-between mb-4">
                <h1 className="text-xl font-bold text-gray-800">階層メモ帳</h1>
                <button onClick={()=>setIsMobileMenuOpen(false)} className="md:hidden p-2 hover:bg-gray-100 rounded"><X size={20}/></button>
              </div>
              {!readOnlyMode && (
                <div className="flex space-x-2">
                  <button onClick={()=>handleAddItem(null,'folder')} className="flex items-center px-3 py-2 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors">
                    <Folder size={16} className="mr-1"/>フォルダ
                  </button>
                  <button onClick={()=>handleAddItem(null,'note')} className="flex items-center px-3 py-2 text-sm bg-green-600 text-white rounded hover:bg-green-700 transition-colors">
                    <FileText size={16} className="mr-1"/>メモ
                  </button>
                </div>
              )}
            </div>

            {!readOnlyMode && (
              <div onDragOver={(e)=>{e.preventDefault(); e.dataTransfer.dropEffect='move'; setHighlightFolderId(null);}}
                   onDrop={handleRootDrop}
                   className="m-2 mb-1 px-3 py-2 text-xs rounded border border-dashed border-blue-300 text-blue-700 bg-blue-50">
                👉 ここにドロップで最上階層へ（先頭に移動）
              </div>
            )}

            <div className="flex-1 overflow-y-auto p-2">
              {items.map(item => renderTreeItem(item))}
            </div>
          </div>

          {/* Main */}
          <div className="flex-1 flex flex-col min-w-0">
            {/* Mobile header */}
            <div className="md:hidden flex items-center justify-between p-4 bg-white border-b border-gray-200">
              <button onClick={()=>setIsMobileMenuOpen(true)} className="p-2 hover:bg-gray-100 rounded"><Folder size={20}/></button>
              <h2 className="text-lg font-semibold text-gray-800">{selectedItem ? selectedItem.name : '階層メモ帳'}</h2>
              <div className="w-10"></div>
            </div>

            {/* Desktop header */}
            <div className="hidden md:flex items-center justify-between p-4 border-b border-gray-200 bg-white">
              <div className="flex items-center">
                {selectedItem?.type==='folder' ? <Folder size={20} className="mr-2 text-blue-600"/> :
                 selectedItem?.type==='note' ? <FileText size={20} className="mr-2 text-gray-600"/> : null}
                <h2 className="text-lg font-semibold text-gray-800">{selectedItem ? selectedItem.name : '階層メモ帳'}</h2>
              </div>

              <div className="flex items-center gap-3">
                {/* 保存インジケーター */}
                <div className="flex items-center gap-2 text-xs text-gray-500">
                  <span className={`inline-block w-2 h-2 rounded-full ${saving ? 'bg-amber-500 animate-pulse' : 'bg-emerald-500'}`}></span>
                  <span>{saving ? '保存中…' : (lastSavedAt ? '保存済み' : '待機中')}</span>
                </div>

                {/* ツールバー（PC編集用） */}
                <div className="flex items-center gap-2">
                  {selectedItem?.type==='note' && !readOnlyMode && (
                    <button onClick={()=>addTableBlock(3,3)} className="flex items-center px-3 py-2 text-sm bg-indigo-600 text-white rounded hover:bg-indigo-700">
                      <TableIcon size={16} /> <span className="ml-1">テーブルを追加</span>
                    </button>
                  )}
                  <button onClick={handleExport} className="px-3 py-2 text-sm bg-gray-100 hover:bg-gray-200 rounded">バックアップ(JSON)</button>
                  <button onClick={handleImportClick} className="px-3 py-2 text-sm bg-gray-100 hover:bg-gray-200 rounded">復元(JSON)</button>
                  <button onClick={handleReset} className="px-3 py-2 text-sm bg-red-50 hover:bg-red-100 text-red-700 rounded">初期化</button>
                  <input ref={fileInputRef} type="file" accept="application/json" className="hidden" onChange={handleImportFile}/>

                  {/* GitHub 同期（PCでの編集/保存用） */}
                  {!readOnlyMode && (
                    <div className="relative">
                      <button onClick={()=>setSyncOpen(v=>!v)} className="px-3 py-2 text-sm bg-black text-white rounded hover:bg-gray-800">GitHub 同期</button>
                      {syncOpen && (
                        <div className="absolute right-0 mt-2 w-[360px] max-w-[90vw] bg-white border rounded-xl shadow-lg p-3 z-30 space-y-3">
                          <div className="text-sm font-semibold">GitHub Gist 同期</div>
                          {syncMsg && <div className="text-xs text-emerald-700 bg-emerald-50 border border-emerald-200 rounded px-2 py-1">{syncMsg}</div>}

                          {/* Token */}
                          <div className="space-y-1">
                            <label className="text-xs text-gray-600">Personal Access Token（gist 権限）</label>
                            <input type="password" value={gistToken} onChange={e=>setGistToken(e.target.value)}
                                   placeholder="ghp_xxx / github_pat_xxx"
                                   className="w-full px-2 py-2 border rounded"/>
                            <div className="flex gap-2">
                              <button onClick={saveToken} className="px-3 py-2 text-sm bg-gray-800 text-white rounded hover:bg-gray-700">トークンを保存</button>
                              <button onClick={clearToken} className="px-3 py-2 text-sm bg-gray-100 rounded hover:bg-gray-200">削除</button>
                            </div>
                            <div className="text-[11px] text-gray-500">※ トークンはこのブラウザの localStorage に保存されます。共有端末では入力しないでください。</div>
                          </div>

                          <hr/>

                          {/* Gist link/create */}
                          <div className="space-y-2">
                            <div className="text-xs text-gray-600">Gist ID をリンクするか、新規作成します</div>
                            <div className="flex gap-2">
                              <input type="text" placeholder="既存の Gist ID（例: a1b2c3...）" className="flex-1 px-2 py-2 border rounded"
                                     value={gistId} onChange={e=>setGistId(e.target.value)} />
                              <button onClick={()=>linkGistId(gistId)} className="px-3 py-2 text-sm bg-gray-100 rounded hover:bg-gray-200">リンク</button>
                            </div>
                            <button onClick={doCreateGist} className="w-full px-3 py-2 text-sm bg-blue-600 text-white rounded hover:bg-blue-700">現在の内容で 新規Gistを作成</button>
                            {gistId && (
                              <a href={`https://gist.github.com/${gistId}`} target="_blank" rel="noreferrer" className="text-xs text-blue-600 underline">
                                Gist を開く
                              </a>
                            )}
                          </div>

                          {/* Actions */}
                          <div className="flex items-center justify-between pt-2">
                            <div className="flex gap-2">
                              <button onClick={doPull} className="px-3 py-2 text-sm bg-gray-100 rounded hover:bg-gray-200">Pull（読み込み）</button>
                              <button onClick={doPush} className="px-3 py-2 text-sm bg-gray-900 text-white rounded hover:bg-gray-800">Push（保存）</button>
                            </div>
                            <label className="flex items-center gap-2 text-xs">
                              <input type="checkbox" checked={autoPush} onChange={toggleAutoPush}/>
                              自動Push
                            </label>
                          </div>

                          <div className="flex justify-end">
                            <button onClick={unlinkGist} className="text-xs text-red-600 hover:underline">Gist リンク解除</button>
                          </div>
                        </div>
                      )}
                    </div>
                  )}
                </div>
              </div>
            </div>

            {selectedItem ? (
              <>
                {selectedItem.type==='note' ? (
                  <div className="flex-1 p-4 space-y-4 overflow-auto">
                    {/* 本文（自動リサイズ） */}
                    <div className="bg-white border rounded-xl">
                      <div className="px-3 py-2 text-xs text-gray-500 border-b bg-gray-50 rounded-t-xl">本文</div>
                      <textarea
                        ref={noteTextareaRef}
                        value={selectedItem.content || ''}
                        onChange={(e)=>handleContentChange(e.target.value)}
                        placeholder="ここにメモを書いてください..."
                        className="w-full min-h-[3rem] p-4 border-0 focus:outline-none rounded-b-xl resize-none overflow-hidden"
                        disabled={readOnlyMode}
                      />
                    </div>

                    {/* ブロック */}
                    <div>
                      <div className="px-1 pb-2 text-xs text-gray-500">ブロック</div>
                      {(selectedItem.blocks && selectedItem.blocks.length > 0) ? (
                        selectedItem.blocks.map(b => b.type==='table' ? <TableBlock key={b.id} block={b}/> : null)
                      ) : (
                        <div className="text-sm text-gray-500">ブロックはありません。{!readOnlyMode && '「テーブルを追加」を押してください。'}</div>
                      )}
                    </div>
                  </div>
                ) : (
                  <div className="flex-1 flex items-center justify-center text-gray-500">
                    <div className="text-center">
                      <Folder size={48} className="mx-auto mb-4 text-gray-400"/>
                      <p>フォルダが選択されています</p>
                      <p className="text-sm">メモを選択して編集してください</p>
                    </div>
                  </div>
                )}
              </>
            ) : (
              <div className="flex-1 flex items-center justify-center text-gray-500">
                <div className="text-center">
                  <FileText size={48} className="mx-auto mb-4 text-gray-400"/>
                  <p>メモまたはフォルダを選択してください</p>
                  <p className="text-sm">左側のサイドバーからアイテムをクリックしてください</p>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    };

    ReactDOM.render(<HierarchicalNotepad/>, document.getElementById('root'));
  </script>
</body>
</html>
