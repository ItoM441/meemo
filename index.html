<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>éšå±¤ãƒ¡ãƒ¢å¸³</title>

  <!-- â–¼ ã‚¹ãƒãƒ›è‡ªå‹•åŒæœŸç”¨ï¼šGistã®ãƒ¦ãƒ¼ã‚¶ãƒ¼åã¨IDã‚’è¨­å®šã—ã¦ãã ã•ã„ â–¼ -->
  <meta name="x-default-gist-user" content="ItoM441">
  <meta name="x-default-gist-id" content="YOUR_GIST_ID_HERE">
  <!-- â–² ã“ã“ã‚’æ›¸ãæ›ãˆã‚‹ã ã‘ã§ã€ã‚¹ãƒãƒ›ã¯é–‹ãã ã‘ã§è‡ªå‹•èª­ã¿è¾¼ã¿ã—ã¾ã™ â–² -->

  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body{margin:0;padding:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto",sans-serif}
    .drop-hint{height:4px;border-radius:9999px}
    input, textarea { font-size: 16px; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    /* ===== Icons ===== */
    const ChevronDown = ({ size=24 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M6 9l6 6 6-6"/></svg>);
    const ChevronRight= ({ size=24 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M9 18l6-6-6-6"/></svg>);
    const Folder      = ({ size=24, className="" }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className={className}><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>);
    const FileText    = ({ size=24, className="" }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className={className}><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><path d="M14 2v6h6M16 13H8M16 17H8M10 9H8"/></svg>);
    const Plus        = ({ size=24 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M12 5v14M5 12h14"/></svg>);
    const Edit2       = ({ size=24 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>);
    const Trash2      = ({ size=24 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>);
    const SaveIcon    = ({ size=24 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17,21 17,13 7,13 7,21"/><polyline points="7,3 7,8 15,8"/></svg>);
    const X           = ({ size=24 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M18 6L6 18M6 6l12 12"/></svg>);
    const TableIcon   = ({ size=24 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg>);
    const Grip        = ({ size=18 }) => (<svg width={size} height={size} viewBox="0 0 24 24" fill="currentColor"><circle cx="7" cy="6" r="1.5"/><circle cx="12" cy="6" r="1.5"/><circle cx="17" cy="6" r="1.5"/><circle cx="7" cy="12" r="1.5"/><circle cx="12" cy="12" r="1.5"/><circle cx="17" cy="12" r="1.5"/><circle cx="7" cy="18" r="1.5"/><circle cx="12" cy="18" r="1.5"/><circle cx="17" cy="18" r="1.5"/></svg>);

    /* ===== Utils & Keys ===== */
    const clone = (o) => JSON.parse(JSON.stringify(o));
    const STORAGE_KEY   = 'hn_items_v3';
    const GIST_TOKEN_KEY= 'hn_gist_token';
    const GIST_ID_KEY   = 'hn_gist_id';
    const AUTO_PUSH_KEY = 'hn_gist_auto_push';

    const sampleItems = () => ([
      { id: '1', type: 'folder', name: 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ', expanded: true,
        children: [
          { id: '2', type: 'note', name: 'ã‚¢ã‚¤ãƒ‡ã‚¢', content: 'ã“ã“ã«ãƒ¡ãƒ¢ã®å†…å®¹ã‚’æ›¸ãã¾ã™...', blocks: [] },
          { id: '3', type: 'folder', name: 'è¨­è¨ˆ', expanded: false,
            children: [{ id: '4', type: 'note', name: 'UIè¨­è¨ˆ', content: 'UIã®æ¤œè¨äº‹é …', blocks: [] }] }
        ]},
      { id: '5', type: 'note', name: 'æ—¥è¨˜', content: 'ä»Šæ—¥ã¯è‰¯ã„ä¸€æ—¥ã§ã—ãŸã€‚', blocks: [] }
    ]);

    function migrateItems(items) {
      const walk = (arr) => arr.map(it => {
        if (it.type === 'note') return { ...it, blocks: Array.isArray(it.blocks)?it.blocks:[], content: typeof it.content==='string'?it.content:'' };
        if (it.children) return { ...it, children: walk(it.children) };
        return it;
      });
      return walk(items);
    }

    function findPathById(items, id, path = []) {
      for (let i = 0; i < items.length; i++) {
        const it = items[i];
        if (it.id === id) return [...path, i];
        if (it.type === 'folder' && Array.isArray(it.children) && it.children.length) {
          const p = findPathById(it.children, id, [...path, i, 'children']);
          if (p) return p;
        }
      }
      return null;
    }
    function getArrayFromParentPath(rootClone, parentPath) {
      let arr = rootClone, obj = null;
      for (const token of parentPath) {
        if (token === 'children') {
          if (!obj) throw new Error('Invalid path: children without object');
          if (!Array.isArray(obj.children)) obj.children = [];
          arr = obj.children; obj = null;
        } else {
          obj = arr[token];
          if (!obj) throw new Error('Invalid path index');
        }
      }
      return arr;
    }
    function removeByPath(items, fullPath) {
      const cloned = clone(items);
      const parentPath = fullPath.slice(0, -1);
      const index = fullPath[fullPath.length - 1];
      const parentArr = getArrayFromParentPath(cloned, parentPath);
      const removed = parentArr.splice(index, 1)[0];
      return { newItems: cloned, removed };
    }
    function insertIntoParentPath(items, parentPath, index, node) {
      const cloned = clone(items);
      const targetArr = getArrayFromParentPath(cloned, parentPath);
      const safeIndex = Math.max(0, Math.min(targetArr.length, index));
      targetArr.splice(safeIndex, 0, node);
      return cloned;
    }
    function getParentPathAndIndex(path) {
      return { parentPath: path.slice(0, -1), index: path[path.length - 1] };
    }
    const newId = (p='id') => `${p}-${Date.now()}-${Math.random().toString(36).slice(2,7)}`;

    /* ===== GitHub Gist API helpers ===== */
    const GH_API = 'https://api.github.com';

    async function ghFetch(token, path, method='GET', body=null, scheme='token') {
      const headers = {
        'Accept':'application/vnd.github+json',
        'X-GitHub-Api-Version':'2022-11-28',
        'Authorization': `${scheme} ${token}`
      };
      const res = await fetch(`${GH_API}${path}`, { method, headers, body: body ? JSON.stringify(body) : null });
      if (res.status === 401 && scheme === 'token') {
        // 401 ã®å ´åˆã¯ Bearer ã§ã‚‚ã†ä¸€åº¦ï¼ˆfine-grained å¯¾å¿œï¼‰
        return ghFetch(token, path, method, body, 'Bearer');
      }
      if (!res.ok) {
        const text = await res.text().catch(()=> '');
        throw new Error(`GitHub API ${res.status}: ${text||res.statusText}`);
      }
      return res.json();
    }

    async function gistCreate(token, items) {
      const body = {
        description: 'Hierarchical Notepad data (notes.json)',
        public: false,
        files: { 'notes.json': { content: JSON.stringify(items, null, 2) } }
      };
      const json = await ghFetch(token, '/gists', 'POST', body);
      return json.id;
    }
    async function gistUpdate(token, gistId, items) {
      const body = { files: { 'notes.json': { content: JSON.stringify(items, null, 2) } } };
      await ghFetch(token, `/gists/${gistId}`, 'PATCH', body);
    }
    async function gistFetch(token, gistId) {
      const json = await ghFetch(token, `/gists/${gistId}`, 'GET');
      const file = json.files?.['notes.json'];
      if (!file) throw new Error('notes.json ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
      if (file.truncated && file.raw_url) {
        const raw = await fetch(file.raw_url, { cache:'no-store' }).then(r=>r.text());
        return JSON.parse(raw);
      }
      if (typeof file.content === 'string') return JSON.parse(file.content);
      if (file.raw_url) {
        const raw = await fetch(file.raw_url, { cache:'no-store' }).then(r=>r.text());
        return JSON.parse(raw);
      }
      throw new Error('Gist ã®å†…å®¹ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚');
    }

    /* â–¼ è¿½åŠ ï¼šãƒˆãƒ¼ã‚¯ãƒ³ä¸è¦ã® Raw å–å¾—ï¼ˆèª­ã¿å–ã‚Šå°‚ç”¨ï¼‰ â–¼ */
    function buildRawUrl(user, gistId, filename='notes.json') {
      return `https://gist.githubusercontent.com/${encodeURIComponent(user)}/${encodeURIComponent(gistId)}/raw/${encodeURIComponent(filename)}`;
    }
    async function gistFetchRawUnauthed(user, gistId) {
      const url = buildRawUrl(user, gistId, 'notes.json');
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Raw fetch ${res.status}`);
      const text = await res.text();
      return JSON.parse(text);
    }
    /* â–² è¿½åŠ ã“ã“ã¾ã§ â–² */

    /* ===== App ===== */
    const HierarchicalNotepad = () => {
      // localStorage â†’ æ—¢å­˜ or ã‚µãƒ³ãƒ—ãƒ«
      const [items, setItems] = React.useState(() => {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (raw) { const data = JSON.parse(raw); if (Array.isArray(data)) return migrateItems(data); }
        } catch {}
        return sampleItems();
      });

      const [selectedItem, setSelectedItem] = React.useState(null);
      const [editingItem, setEditingItem] = React.useState(null);
      const [editValue, setEditValue] = React.useState('');
      const [draggedId, setDraggedId] = React.useState(null);
      const [dropHint, setDropHint] = React.useState(null);
      const [highlightFolderId, setHighlightFolderId] = React.useState(null);
      const [isMobileMenuOpen, setIsMobileMenuOpen] = React.useState(false);

      // ä¿å­˜UI
      const [saving, setSaving] = React.useState(false);
      const [lastSavedAt, setLastSavedAt] = React.useState(null);
      const saveTimerRef = React.useRef(null);

      // Gist åŒæœŸçŠ¶æ…‹
      const [gistToken, setGistToken] = React.useState(() => localStorage.getItem(GIST_TOKEN_KEY) || '');
      const [gistId, setGistId]       = React.useState(() => localStorage.getItem(GIST_ID_KEY) || '');
      const [autoPush, setAutoPush]   = React.useState(() => localStorage.getItem(AUTO_PUSH_KEY) === '1');
      const [syncOpen, setSyncOpen]   = React.useState(false);
      const [syncMsg, setSyncMsg]     = React.useState('');

      /* â–¼ è¿½åŠ ï¼šã‚¹ãƒãƒ›ã§ã‚‚é–‹ãã ã‘ã§è‡ªå‹•åŒæœŸï¼ˆèª­ã¿å–ã‚Šå°‚ç”¨ãƒ¢ãƒ¼ãƒ‰ï¼‰ â–¼
         - URL ?gist=...&user=... ãŒã‚ã‚Œã°ãã‚Œã‚’å„ªå…ˆ
         - ãªã‘ã‚Œã° <meta name="x-default-gist-user/id"> ã‚’ä½¿ã†
         - ãƒˆãƒ¼ã‚¯ãƒ³ãŒæœªè¨­å®šã®ã¨ãã ã‘æœ‰åŠ¹ï¼ˆï¼ã‚¹ãƒãƒ›å´ï¼‰ */
      const urlParams = new URLSearchParams(window.location.search);
      const qsGist = urlParams.get('gist') || '';
      const qsUser = urlParams.get('user') || '';
      const metaUser = document.querySelector('meta[name="x-default-gist-user"]')?.content || '';
      const metaId   = document.querySelector('meta[name="x-default-gist-id"]')?.content || '';
      const roUser = qsUser || metaUser;
      const roGist = qsGist || metaId;
      const readOnlyMode = (!gistToken) && !!roUser && !!roGist;

      const [lastPulledAt, setLastPulledAt] = React.useState(null);
      React.useEffect(() => {
        if (!readOnlyMode) return;
        let stop = false;
        const pull = async () => {
          try {
            const data = await gistFetchRawUnauthed(roUser, roGist);
            if (Array.isArray(data)) {
              setItems(migrateItems(data));
              setSelectedItem(null);
              setLastPulledAt(Date.now());
              try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); } catch {}
            }
          } catch (e) {
            console.warn('è‡ªå‹•Pullå¤±æ•—:', e.message);
          }
        };
        pull(); // åˆå›
        const t = setInterval(() => { if (!stop) pull(); }, 8000); // 8ç§’æ¯
        return () => { stop = true; clearInterval(t); };
      }, [readOnlyMode, roUser, roGist]);
      /* â–² è¿½åŠ ã“ã“ã¾ã§ â–² */

      // è‡ªå‹•ä¿å­˜ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ï¼‰
      React.useEffect(() => {
        setSaving(true);
        if (saveTimerRef.current) clearTimeout(saveTimerRef.current);
        saveTimerRef.current = setTimeout(() => {
          try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(items));
            setLastSavedAt(Date.now());
          } catch (e) { console.error('ä¿å­˜å¤±æ•—: ', e); }
          setSaving(false);
        }, 300);
        return () => clearTimeout(saveTimerRef.current);
      }, [items]);

      // ç”»é¢å¤–èª¤ãƒ‰ãƒ­ãƒƒãƒ—é˜²æ­¢
      React.useEffect(() => {
        const prevent = e => e.preventDefault();
        window.addEventListener('dragover', prevent);
        window.addEventListener('drop', prevent);
        return () => { window.removeEventListener('dragover', prevent); window.removeEventListener('drop', prevent); };
      }, []);

      // ã‚ªãƒ¼ãƒˆPushï¼ˆç¯€ç´„ã®ãŸã‚ 2 ç§’ãƒ‡ãƒã‚¦ãƒ³ã‚¹ï¼‰
      const autoPushTimer = React.useRef(null);
      React.useEffect(() => {
        if (!autoPush || !gistToken || !gistId) return;
        if (autoPushTimer.current) clearTimeout(autoPushTimer.current);
        autoPushTimer.current = setTimeout(async () => {
          try {
            await gistUpdate(gistToken, gistId, items);
            setSyncMsg('Gistã¸è‡ªå‹•ä¿å­˜ã—ã¾ã—ãŸ');
            setTimeout(()=> setSyncMsg(''), 1500);
          } catch (e) {
            setSyncMsg('è‡ªå‹•ä¿å­˜ã«å¤±æ•—: ' + e.message);
            setTimeout(()=> setSyncMsg(''), 2500);
          }
        }, 2000);
        return () => clearTimeout(autoPushTimer.current);
      }, [items, autoPush, gistToken, gistId]);

      /* ===== Note helpers ===== */
      const updateNoteById = (noteId, updater) => {
        const walk = (arr) => arr.map(it => {
          if (it.id === noteId && it.type === 'note') return updater({ ...it, blocks: it.blocks || [] });
          if (it.children) return { ...it, children: walk(it.children) };
          return it;
        });
        setItems(prev => walk(prev));
        setSelectedItem(prev => {
          if (!prev || prev.id !== noteId || prev.type !== 'note') return prev;
          return updater({ ...prev, blocks: prev.blocks || [] });
        });
      };

      /* ===== CRUD ===== */
      const removeItem = (arr, id) => arr.filter(it => {
        if (it.id === id) return false;
        if (it.children) it.children = removeItem(it.children, id);
        return true;
      });
      const addItemToParent = (arr, parentId, newItem) => arr.map(it => {
        if (it.id === parentId && it.type === 'folder') return { ...it, children: [ ...(it.children || []), newItem ] };
        if (it.children) return { ...it, children: addItemToParent(it.children, parentId, newItem) };
        return it;
      });

      const handleToggleExpand = (id) => {
        const walk = a => a.map(it => {
          if (it.id === id) return { ...it, expanded: !it.expanded };
          if (it.children) return { ...it, children: walk(it.children) };
          return it;
        });
        setItems(walk(items));
      };

      const handleSelectItem = (item) => {
        setSelectedItem(item.type === 'note' ? { ...item, blocks: item.blocks || [] } : item);
        setEditingItem(null);
        if (window.innerWidth < 768) setIsMobileMenuOpen(false);
      };

      const handleStartEdit = (item, e) => {
        e.stopPropagation();
        if (readOnlyMode) return;
        setEditingItem(item.id);
        setEditValue(item.name);
      };

      const handleSaveEdit = () => {
        const walk = a => a.map(it => {
          if (it.id === editingItem) return { ...it, name: editValue };
          if (it.children) return { ...it, children: walk(it.children) };
          return it;
        });
        setItems(walk(items));
        setEditingItem(null);
        setEditValue('');
      };
      const handleCancelEdit = () => { setEditingItem(null); setEditValue(''); };

      const handleDeleteItem = (id, e) => {
        e?.stopPropagation?.();
        if (readOnlyMode) return;
        setItems(removeItem(items, id));
        if (selectedItem?.id === id) setSelectedItem(null);
      };

      const handleAddItem = (parentId, type) => {
        if (readOnlyMode) return;
        const newItem = {
          id: Date.now().toString(),
          type,
          name: type === 'folder' ? 'æ–°ã—ã„ãƒ•ã‚©ãƒ«ãƒ€' : 'æ–°ã—ã„ãƒ¡ãƒ¢',
          ...(type === 'folder' ? { expanded: true, children: [] } : { content: '', blocks: [] })
        };
        if (parentId) setItems(addItemToParent(items, parentId, newItem));
        else setItems([ newItem, ...items ]);
      };

      /* ===== Note content auto-resize ===== */
      const noteTextareaRef = React.useRef(null);
      const autoResize = el => { if (!el) return; el.style.height = 'auto'; el.style.height = (el.scrollHeight) + 'px'; };
      React.useEffect(() => { autoResize(noteTextareaRef.current); }, [selectedItem?.id]);
      const handleContentChange = (content) => {
        if (!selectedItem || selectedItem.type !== 'note' || readOnlyMode) return;
        updateNoteById(selectedItem.id, (note) => ({ ...note, content }));
        requestAnimationFrame(()=> autoResize(noteTextareaRef.current));
      };

      /* ===== Table Blocks ===== */
      const addTableBlock = (rows=3, cols=3) => {
        if (!selectedItem || selectedItem.type !== 'note' || readOnlyMode) return;
        const data = Array.from({length: rows}, () => Array.from({length: cols}, () => ''));
        const block = { id: newId('tbl'), type: 'table', rows, cols, data, title: 'ãƒ†ãƒ¼ãƒ–ãƒ«' };
        updateNoteById(selectedItem.id, (note) => ({ ...note, blocks: [...(note.blocks||[]), block] }));
      };
      const updateCell = (blockId, r, c, value) => {
        if (readOnlyMode) return;
        updateNoteById(selectedItem.id, (note) => {
          const blocks = (note.blocks||[]).map(b => {
            if (b.id !== blockId) return b;
            const data = b.data.map((row, ri) => row.map((cell, ci) => (ri===r && ci===c ? value : cell)));
            return { ...b, data };
          });
          return { ...note, blocks };
        });
      };
      const addRow = (blockId) => {
        if (readOnlyMode) return;
        updateNoteById(selectedItem.id, (note) => {
          const blocks = (note.blocks||[]).map(b => b.id!==blockId ? b : ({ ...b, data:[...b.data, Array.from({length:b.cols},()=> '')], rows:b.rows+1 }));
          return { ...note, blocks };
        });
      };
      const addCol = (blockId) => {
        if (readOnlyMode) return;
        updateNoteById(selectedItem.id, (note) => {
          const blocks = (note.blocks||[]).map(b => {
            if (b.id!==blockId) return b;
            return { ...b, data: b.data.map(row=>[...row,'']), cols:b.cols+1 };
          });
          return { ...note, blocks };
        });
      };
      const deleteBlock = (blockId) => {
        if (readOnlyMode) return;
        updateNoteById(selectedItem.id, (note) => ({ ...note, blocks: (note.blocks||[]).filter(b => b.id!==blockId) }));
      };
      const renameBlock = (blockId, title) => {
        if (readOnlyMode) return;
        updateNoteById(selectedItem.id, (note) => ({ ...note, blocks: (note.blocks||[]).map(b => b.id===blockId?{...b,title}:b) }));
      };

      /* ===== Reorder/Move (DnD) ===== */
      const moveDraggedTo = (sourceId, targetId, mode/* 'before'|'after'|'into' */) => {
        if (readOnlyMode) return;
        const srcPath = findPathById(items, sourceId); if (!srcPath) return;
        const { newItems, removed } = removeByPath(items, srcPath);

        if (mode === 'into') {
          const tgtPath = findPathById(newItems, targetId); if (!tgtPath) { setItems(newItems); return; }
          const inserted = insertIntoParentPath(newItems, [...tgtPath, 'children'], Number.MAX_SAFE_INTEGER, removed);
          setItems(inserted);
          return;
        }

        const tgtPath = findPathById(newItems, targetId); if (!tgtPath) { setItems(newItems); return; }
        const { parentPath: tgtParentPath, index: tgtIndex } = getParentPathAndIndex(tgtPath);
        const srcParentPathJSON = JSON.stringify(srcPath.slice(0, -1));
        const tgtParentPathJSON = JSON.stringify(tgtParentPath);
        let insertIndex = (mode === 'before') ? tgtIndex : tgtIndex + 1;
        const sameParent = srcParentPathJSON === tgtParentPathJSON;
        const srcIndex = srcPath[srcPath.length - 1];
        if (sameParent && srcIndex < tgtIndex && mode === 'after') insertIndex -= 1;

        const inserted = insertIntoParentPath(newItems, tgtParentPath, insertIndex, removed);
        setItems(inserted);
      };

      const computeDropPosition = (e, targetEl, targetItem) => {
        const rect = targetEl.getBoundingClientRect();
        const y = e.clientY;
        const topZone = rect.top + rect.height * 0.30;
        const bottomZone = rect.bottom - rect.height * 0.30;
        if (targetItem.type === 'folder' && y >= topZone && y <= bottomZone) return 'into';
        return (y < rect.top + rect.height/2) ? 'before' : 'after';
      };

      const handleDragStart = (e, item) => {
        if (readOnlyMode) return;
        setDraggedId(item.id);
        setHighlightFolderId(null);
        try { e.dataTransfer.setData('text/plain', item.id); } catch {}
        e.dataTransfer.effectAllowed = 'move';
        if (e.currentTarget && e.dataTransfer.setDragImage) {
          e.dataTransfer.setDragImage(e.currentTarget, 10, 10);
        }
      };
      const handleDragOverItem = (e, item) => {
        e.preventDefault(); e.stopPropagation();
        if (readOnlyMode) return;
        if (!draggedId || draggedId === item.id) return;
        const pos = computeDropPosition(e, e.currentTarget, item);
        if (pos === 'into') {
          setHighlightFolderId(item.id); setDropHint(null);
        } else {
          setHighlightFolderId(null); setDropHint({ targetId: item.id, pos });
        }
        e.dataTransfer.dropEffect = 'move';
      };
      const handleDropOnItem = (e, targetItem) => {
        e.preventDefault(); e.stopPropagation();
        if (readOnlyMode) return;
        const sourceId = draggedId; setDraggedId(null);
        if (!sourceId || sourceId === targetItem.id) { setDropHint(null); setHighlightFolderId(null); return; }
        const pos = computeDropPosition(e, e.currentTarget, targetItem);
        moveDraggedTo(sourceId, targetItem.id, pos);
        setDropHint(null); setHighlightFolderId(null);
      };
      const handleRootDrop = (e) => {
        e.preventDefault();
        if (readOnlyMode) return;
        const sourceId = draggedId; setDraggedId(null);
        if (!sourceId) return;
        const srcPath = findPathById(items, sourceId); if (!srcPath) return;
        const { newItems, removed } = removeByPath(items, srcPath);
        const inserted = insertIntoParentPath(newItems, [], 0, removed);
        setItems(inserted); setDropHint(null); setHighlightFolderId(null);
      };

      /* ===== Touch DnD (mobile handle) ===== */
      const startTouchDrag = (e, item) => {
        if (readOnlyMode) return;
        e.preventDefault();
        setDraggedId(item.id);
        const onMove = (ev) => {
          const t = ev.touches ? ev.touches[0] : ev;
          const el = document.elementFromPoint(t.clientX, t.clientY);
          if (!el) return;
          let node = el; while (node && !node.dataset?.treeId) node = node.parentElement;
          if (!node || !node.dataset?.treeId) { setDropHint(null); setHighlightFolderId(null); return; }
          const targetId = node.dataset.treeId;
          if (targetId === item.id) { setDropHint(null); setHighlightFolderId(null); return; }
          const rect = node.getBoundingClientRect();
          const y = t.clientY, topZone = rect.top + rect.height*0.30, bottomZone = rect.bottom - rect.height*0.30;
          const targetType = node.dataset.treeType;
          if (targetType === 'folder' && y >= topZone && y <= bottomZone) { setHighlightFolderId(targetId); setDropHint(null); }
          else { setHighlightFolderId(null); setDropHint({ targetId, pos: (y < rect.top + rect.height/2) ? 'before':'after' }); }
          ev.preventDefault();
        };
        const onEnd = () => {
          if (highlightFolderId) moveDraggedTo(item.id, highlightFolderId, 'into');
          else if (dropHint?.targetId && dropHint?.pos) moveDraggedTo(item.id, dropHint.targetId, dropHint.pos);
          setDropHint(null); setHighlightFolderId(null); setDraggedId(null);
          window.removeEventListener('touchmove', onMove, { passive:false });
          window.removeEventListener('touchend', onEnd);
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onEnd);
        };
        window.addEventListener('touchmove', onMove, { passive:false });
        window.addEventListener('touchend', onEnd);
        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onEnd);
      };

      /* ===== Export / Import / Reset ===== */
      const fileInputRef = React.useRef(null);
      const handleExport = () => {
        const blob = new Blob([JSON.stringify(items, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'notepad-data.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      };
      const handleImportClick = () => fileInputRef.current?.click();
      const handleImportFile = (e) => {
        const file = e.target.files?.[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const data = JSON.parse(reader.result);
            if (!Array.isArray(data)) throw new Error('JSONã®å½¢å¼ãŒé•ã„ã¾ã™ï¼ˆé…åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼‰');
            setItems(migrateItems(data)); setSelectedItem(null);
          } catch (err) { alert('èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + err.message); }
          finally { e.target.value=''; }
        };
        reader.readAsText(file, 'utf-8');
      };
      const handleReset = () => {
        if (!confirm('ã™ã¹ã¦ã®ãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ã‚’æ¶ˆã—ã¦åˆæœŸçŠ¶æ…‹ã«æˆ»ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) return;
        localStorage.removeItem(STORAGE_KEY);
        setItems(sampleItems());
        setSelectedItem(null);
      };

      /* ===== Gist UI handlersï¼ˆPCç·¨é›†ç”¨ï¼‰ ===== */
      const saveToken = () => {
        if (!gistToken) { alert('ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
        localStorage.setItem(GIST_TOKEN_KEY, gistToken);
        setSyncMsg('ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
        setTimeout(()=> setSyncMsg(''), 1500);
      };
      const clearToken = () => {
        localStorage.removeItem(GIST_TOKEN_KEY);
        setGistToken(''); setSyncMsg('ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å‰Šé™¤ã—ã¾ã—ãŸ'); setTimeout(()=> setSyncMsg(''), 1500);
      };
      const linkGistId = (id) => {
        if (!id) { alert('Gist ID ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
        localStorage.setItem(GIST_ID_KEY, id);
        setGistId(id); setSyncMsg('Gist ã‚’ãƒªãƒ³ã‚¯ã—ã¾ã—ãŸ'); setTimeout(()=> setSyncMsg(''), 1500);
      };
      const unlinkGist = () => {
        localStorage.removeItem(GIST_ID_KEY);
        setGistId(''); setSyncMsg('Gist ãƒªãƒ³ã‚¯ã‚’è§£é™¤ã—ã¾ã—ãŸ'); setTimeout(()=> setSyncMsg(''), 1500);
      };
      const doCreateGist = async () => {
        if (!gistToken) { alert('ãƒˆãƒ¼ã‚¯ãƒ³ãŒå¿…è¦ã§ã™'); return; }
        try {
          const id = await gistCreate(gistToken, items);
          localStorage.setItem(GIST_ID_KEY, id);
          setGistId(id);
          setSyncMsg('æ–°è¦Gistã‚’ä½œæˆã—ã¾ã—ãŸ');
          setTimeout(()=> setSyncMsg(''), 1500);
        } catch (e) {
          alert('Gistä½œæˆã«å¤±æ•—: ' + e.message);
        }
      };
      const doPush = async () => {
        if (!gistToken || !gistId) { alert('ãƒˆãƒ¼ã‚¯ãƒ³ã¨Gist IDãŒå¿…è¦ã§ã™'); return; }
        try {
          await gistUpdate(gistToken, gistId, items);
          setSyncMsg('Gistã¸ä¿å­˜ã—ã¾ã—ãŸ');
          setTimeout(()=> setSyncMsg(''), 1500);
        } catch (e) {
          alert('ä¿å­˜ã«å¤±æ•—: ' + e.message);
        }
      };
      const doPull = async () => {
        if (!gistToken || !gistId) { alert('ãƒˆãƒ¼ã‚¯ãƒ³ã¨Gist IDãŒå¿…è¦ã§ã™'); return; }
        if (!confirm('Gistã®å†…å®¹ã§ç¾åœ¨ã®ãƒ¡ãƒ¢ã‚’ä¸Šæ›¸ãã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) return;
        try {
          const data = await gistFetch(gistToken, gistId);
          if (!Array.isArray(data)) throw new Error('Gistå†…ã® JSON ãŒé…åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“');
          setItems(migrateItems(data)); setSelectedItem(null);
          setSyncMsg('Gistã‹ã‚‰èª­ã¿è¾¼ã¿ã¾ã—ãŸ');
          setTimeout(()=> setSyncMsg(''), 1500);
        } catch (e) {
          alert('èª­ã¿è¾¼ã¿ã«å¤±æ•—: ' + e.message);
        }
      };
      const toggleAutoPush = () => {
        const next = !autoPush; setAutoPush(next);
        localStorage.setItem(AUTO_PUSH_KEY, next ? '1' : '0');
        setSyncMsg(next ? 'è‡ªå‹•Pushã‚’æœ‰åŠ¹åŒ–' : 'è‡ªå‹•Pushã‚’ç„¡åŠ¹åŒ–');
        setTimeout(()=> setSyncMsg(''), 1200);
      };

      /* ===== Table Block ===== */
      const TableBlock = ({ block }) => {
        const [title, setTitle] = React.useState(block.title || 'ãƒ†ãƒ¼ãƒ–ãƒ«');
        React.useEffect(() => { setTitle(block.title || 'ãƒ†ãƒ¼ãƒ–ãƒ«'); }, [block.id, block.title]);
        return (
          <div className="mb-4 border rounded-xl overflow-hidden bg-white shadow-sm">
            <div className="flex items-center justify-between px-3 py-2 bg-gray-50 border-b">
              <div className="flex items-center gap-2">
                <TableIcon size={18}/>
                <input className="px-2 py-1 border rounded w-56 text-sm" value={title}
                  onChange={(e)=>!readOnlyMode && setTitle(e.target.value)}
                  onBlur={()=>!readOnlyMode && renameBlock(block.id, title)} placeholder="ãƒ†ãƒ¼ãƒ–ãƒ«å" disabled={readOnlyMode}/>
              </div>
              <div className="flex items-center gap-2">
                <button onClick={()=>addRow(block.id)} className="px-2 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50" disabled={readOnlyMode}>è¡Œã‚’è¿½åŠ </button>
                <button onClick={()=>addCol(block.id)} className="px-2 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50" disabled={readOnlyMode}>åˆ—ã‚’è¿½åŠ </button>
                <button onClick={()=>deleteBlock(block.id)} className="px-2 py-1 text-sm bg-red-600 text-white rounded hover:bg-red-700 disabled:opacity-50" disabled={readOnlyMode}>å‰Šé™¤</button>
              </div>
            </div>
            <div className="overflow-auto">
              <table className="min-w-full table-fixed border-collapse">
                <tbody>
                  {block.data.map((row, ri) => (
                    <tr key={ri}>
                      {row.map((cell, ci) => (
                        <td key={ci} className="border p-0 align-top">
                          <input className="w-full p-2 outline-none"
                            value={cell}
                            onChange={(e)=>updateCell(block.id, ri, ci, e.target.value)}
                            placeholder={`R${ri+1}C${ci+1}`}
                            disabled={readOnlyMode}/>
                        </td>
                      ))}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        );
      };

      /* ===== Sidebar item render ===== */
      const renderTreeItem = (item, depth=0) => {
        const isEditing = editingItem === item.id;
        const isDragged = draggedId === item.id;
        const isHighlightedFolder = item.type === 'folder' && highlightFolderId === item.id;
        const hintBefore = dropHint?.targetId === item.id && dropHint?.pos === 'before';
        const hintAfter  = dropHint?.targetId === item.id && dropHint?.pos === 'after';

        return (
          <div key={item.id}>
            {hintBefore && !readOnlyMode && <div className="drop-hint bg-blue-500 mx-1" style={{marginLeft:`${depth*16+8}px`}}/>}

            <div
              data-tree-id={item.id}
              data-tree-type={item.type}
              className={`flex items-center py-2 px-2 rounded cursor-pointer select-none transition-colors
                ${selectedItem?.id === item.id ? 'bg-blue-100' : isHighlightedFolder ? 'bg-yellow-100 ring-2 ring-yellow-300' : 'hover:bg-gray-100'}
                ${isDragged ? 'opacity-50' : ''}`}
              style={{ marginLeft: `${depth * 16}px`, touchAction: 'manipulation' }}
              onClick={() => handleSelectItem(item)}
              draggable={!isEditing && !readOnlyMode}
              onDragStart={(e)=>handleDragStart(e,item)}
              onDragEnter={(e)=>handleDragOverItem(e,item)}
              onDragOver={(e)=>handleDragOverItem(e,item)}
              onDrop={(e)=>handleDropOnItem(e,item)}
            >
              {item.type === 'folder' && (
                <button onClick={(e)=>{e.stopPropagation();handleToggleExpand(item.id);}}
                        className="mr-1 p-1 hover:bg-gray-200 rounded">
                  {item.expanded ? <ChevronDown size={16}/> : <ChevronRight size={16}/>}
                </button>
              )}

              <div className="mr-2 flex-shrink-0">
                {item.type === 'folder'
                  ? <Folder size={16} className={isHighlightedFolder ? "text-yellow-600" : "text-blue-600"} />
                  : <FileText size={16} className="text-gray-600" />
                }
              </div>

              {isEditing ? (
                <div className="flex items-center flex-1">
                  <input
                    value={editValue}
                    onChange={(e)=>setEditValue(e.target.value)}
                    onKeyDown={(e)=>{ if(e.key==='Enter') handleSaveEdit(); if(e.key==='Escape') handleCancelEdit(); }}
                    className="flex-1 px-2 py-1 border border-blue-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                    autoFocus
                  />
                  <button onClick={handleSaveEdit} className="ml-2 p-1 text-green-600 hover:bg-green-100 rounded"><SaveIcon size={14}/></button>
                  <button onClick={handleCancelEdit} className="ml-1 p-1 text-red-600 hover:bg-red-100 rounded"><X size={14}/></button>
                </div>
              ) : (
                <>
                  <span className="flex-1 text-sm">{item.name}</span>

                  {/* ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆèª­ã¿å–ã‚Šå°‚ç”¨ã§ã¯éè¡¨ç¤ºï¼‰ */}
                  {!readOnlyMode && (
                    <div className="flex items-center space-x-1">
                      <button className="p-1 text-gray-600 hover:bg-gray-100 rounded md:hidden" title="ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ä¸¦ã¹æ›¿ãˆ" onTouchStart={(e)=>startTouchDrag(e, item)}><Grip /></button>
                      <button onClick={(e)=>handleStartEdit(item,e)} className="p-1 text-blue-600 hover:bg-blue-100 rounded" title="åå‰ã‚’ç·¨é›†"><Edit2 size={12}/></button>
                      {item.type === 'folder' && (
                        <>
                          <button onClick={(e)=>{e.stopPropagation();handleAddItem(item.id,'folder');}}
                                  className="p-1 text-blue-600 hover:bg-blue-100 rounded" title="ãƒ•ã‚©ãƒ«ãƒ€ã‚’è¿½åŠ "><Folder size={12}/></button>
                          <button onClick={(e)=>{e.stopPropagation();handleAddItem(item.id,'note');}}
                                  className="p-1 text-green-600 hover:bg-green-100 rounded" title="ãƒ¡ãƒ¢ã‚’è¿½åŠ "><FileText size={12}/></button>
                        </>
                      )}
                      <button onClick={(e)=>handleDeleteItem(item.id,e)} className="p-1 text-red-600 hover:bg-red-100 rounded" title="å‰Šé™¤"><Trash2 size={12}/></button>
                    </div>
                  )}
                </>
              )}
            </div>

            {hintAfter && !readOnlyMode && <div className="drop-hint bg-blue-500 mx-1" style={{marginLeft:`${depth*16+8}px`}}/>}

            {item.type === 'folder' && item.expanded && item.children && (
              <div>{item.children.map(ch => renderTreeItem(ch, depth+1))}</div>
            )}
          </div>
        );
      };

      /* ===== Layout ===== */
      return (
        <div className="flex h-screen bg-gray-50 relative">
          {/* èª­ã¿å–ã‚Šå°‚ç”¨ãƒãƒŠãƒ¼ */}
          {readOnlyMode && (
            <div className="fixed top-2 inset-x-2 z-40 flex items-center justify-center">
              <div className="px-3 py-2 rounded-full text-xs bg-amber-100 text-amber-800 border border-amber-300 shadow">
                é–²è¦§ãƒ¢ãƒ¼ãƒ‰ï¼šGistï¼ˆ{roUser}/{roGist.slice(0,7)}â€¦ï¼‰ã‹ã‚‰è‡ªå‹•èª­è¾¼ä¸­ {lastPulledAt ? `ï¼ˆæ›´æ–°: ${new Date(lastPulledAt).toLocaleTimeString()}ï¼‰` : ''}
              </div>
            </div>
          )}

          {/* Mobile overlay */}
          {isMobileMenuOpen && <div className="fixed inset-0 bg-black bg-opacity-50 z-10 md:hidden" onClick={()=>setIsMobileMenuOpen(false)}/>}

          {/* Sidebar */}
          <div className={`${isMobileMenuOpen ? 'translate-x-0' : '-translate-x-full'}
              fixed inset-y-0 left-0 z-20 w-80 bg-white border-r border-gray-200 flex flex-col transform transition-transform duration-300 ease-in-out md:relative md:translate-x-0 md:w-1/3`}>
            <div className="p-4 border-b border-gray-200">
              <div className="flex items-center justify-between mb-4">
                <h1 className="text-xl font-bold text-gray-800">éšå±¤ãƒ¡ãƒ¢å¸³</h1>
                <button onClick={()=>setIsMobileMenuOpen(false)} className="md:hidden p-2 hover:bg-gray-100 rounded"><X size={20}/></button>
              </div>
              {!readOnlyMode && (
                <div className="flex space-x-2">
                  <button onClick={()=>handleAddItem(null,'folder')} className="flex items-center px-3 py-2 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors">
                    <Folder size={16} className="mr-1"/>ãƒ•ã‚©ãƒ«ãƒ€
                  </button>
                  <button onClick={()=>handleAddItem(null,'note')} className="flex items-center px-3 py-2 text-sm bg-green-600 text-white rounded hover:bg-green-700 transition-colors">
                    <FileText size={16} className="mr-1"/>ãƒ¡ãƒ¢
                  </button>
                </div>
              )}
            </div>

            {!readOnlyMode && (
              <div onDragOver={(e)=>{e.preventDefault(); e.dataTransfer.dropEffect='move'; setHighlightFolderId(null);}}
                   onDrop={handleRootDrop}
                   className="m-2 mb-1 px-3 py-2 text-xs rounded border border-dashed border-blue-300 text-blue-700 bg-blue-50">
                ğŸ‘‰ ã“ã“ã«ãƒ‰ãƒ­ãƒƒãƒ—ã§æœ€ä¸Šéšå±¤ã¸ï¼ˆå…ˆé ­ã«ç§»å‹•ï¼‰
              </div>
            )}

            <div className="flex-1 overflow-y-auto p-2">
              {items.map(item => renderTreeItem(item))}
            </div>
          </div>

          {/* Main */}
          <div className="flex-1 flex flex-col min-w-0">
            {/* Mobile header */}
            <div className="md:hidden flex items-center justify-between p-4 bg-white border-b border-gray-200">
              <button onClick={()=>setIsMobileMenuOpen(true)} className="p-2 hover:bg-gray-100 rounded"><Folder size={20}/></button>
              <h2 className="text-lg font-semibold text-gray-800">{selectedItem ? selectedItem.name : 'éšå±¤ãƒ¡ãƒ¢å¸³'}</h2>
              <div className="w-10"></div>
            </div>

            {/* Desktop header */}
            <div className="hidden md:flex items-center justify-between p-4 border-b border-gray-200 bg-white">
              <div className="flex items-center">
                {selectedItem?.type==='folder' ? <Folder size={20} className="mr-2 text-blue-600"/> :
                 selectedItem?.type==='note' ? <FileText size={20} className="mr-2 text-gray-600"/> : null}
                <h2 className="text-lg font-semibold text-gray-800">{selectedItem ? selectedItem.name : 'éšå±¤ãƒ¡ãƒ¢å¸³'}</h2>
              </div>

              <div className="flex items-center gap-3">
                {/* ä¿å­˜ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ */}
                <div className="flex items-center gap-2 text-xs text-gray-500">
                  <span className={`inline-block w-2 h-2 rounded-full ${saving ? 'bg-amber-500 animate-pulse' : 'bg-emerald-500'}`}></span>
                  <span>{saving ? 'ä¿å­˜ä¸­â€¦' : (lastSavedAt ? 'ä¿å­˜æ¸ˆã¿' : 'å¾…æ©Ÿä¸­')}</span>
                </div>

                {/* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ï¼ˆPCç·¨é›†ç”¨ï¼‰ */}
                <div className="flex items-center gap-2">
                  {selectedItem?.type==='note' && !readOnlyMode && (
                    <button onClick={()=>addTableBlock(3,3)} className="flex items-center px-3 py-2 text-sm bg-indigo-600 text-white rounded hover:bg-indigo-700">
                      <TableIcon size={16} /> <span className="ml-1">ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è¿½åŠ </span>
                    </button>
                  )}
                  <button onClick={handleExport} className="px-3 py-2 text-sm bg-gray-100 hover:bg-gray-200 rounded">ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—(JSON)</button>
                  <button onClick={handleImportClick} className="px-3 py-2 text-sm bg-gray-100 hover:bg-gray-200 rounded">å¾©å…ƒ(JSON)</button>
                  <button onClick={handleReset} className="px-3 py-2 text-sm bg-red-50 hover:bg-red-100 text-red-700 rounded">åˆæœŸåŒ–</button>
                  <input ref={fileInputRef} type="file" accept="application/json" className="hidden" onChange={handleImportFile}/>

                  {/* GitHub åŒæœŸï¼ˆPCã§ã®ç·¨é›†/ä¿å­˜ç”¨ï¼‰ */}
                  {!readOnlyMode && (
                    <div className="relative">
                      <button onClick={()=>setSyncOpen(v=>!v)} className="px-3 py-2 text-sm bg-black text-white rounded hover:bg-gray-800">GitHub åŒæœŸ</button>
                      {syncOpen && (
                        <div className="absolute right-0 mt-2 w-[360px] max-w-[90vw] bg-white border rounded-xl shadow-lg p-3 z-30 space-y-3">
                          <div className="text-sm font-semibold">GitHub Gist åŒæœŸ</div>
                          {syncMsg && <div className="text-xs text-emerald-700 bg-emerald-50 border border-emerald-200 rounded px-2 py-1">{syncMsg}</div>}

                          {/* Token */}
                          <div className="space-y-1">
                            <label className="text-xs text-gray-600">Personal Access Tokenï¼ˆgist æ¨©é™ï¼‰</label>
                            <input type="password" value={gistToken} onChange={e=>setGistToken(e.target.value)}
                                   placeholder="ghp_xxx / github_pat_xxx"
                                   className="w-full px-2 py-2 border rounded"/>
                            <div className="flex gap-2">
                              <button onClick={saveToken} className="px-3 py-2 text-sm bg-gray-800 text-white rounded hover:bg-gray-700">ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿å­˜</button>
                              <button onClick={clearToken} className="px-3 py-2 text-sm bg-gray-100 rounded hover:bg-gray-200">å‰Šé™¤</button>
                            </div>
                            <div className="text-[11px] text-gray-500">â€» ãƒˆãƒ¼ã‚¯ãƒ³ã¯ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã® localStorage ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚å…±æœ‰ç«¯æœ«ã§ã¯å…¥åŠ›ã—ãªã„ã§ãã ã•ã„ã€‚</div>
                          </div>

                          <hr/>

                          {/* Gist link/create */}
                          <div className="space-y-2">
                            <div className="text-xs text-gray-600">Gist ID ã‚’ãƒªãƒ³ã‚¯ã™ã‚‹ã‹ã€æ–°è¦ä½œæˆã—ã¾ã™</div>
                            <div className="flex gap-2">
                              <input type="text" placeholder="æ—¢å­˜ã® Gist IDï¼ˆä¾‹: a1b2c3...ï¼‰" className="flex-1 px-2 py-2 border rounded"
                                     value={gistId} onChange={e=>setGistId(e.target.value)} />
                              <button onClick={()=>linkGistId(gistId)} className="px-3 py-2 text-sm bg-gray-100 rounded hover:bg-gray-200">ãƒªãƒ³ã‚¯</button>
                            </div>
                            <button onClick={doCreateGist} className="w-full px-3 py-2 text-sm bg-blue-600 text-white rounded hover:bg-blue-700">ç¾åœ¨ã®å†…å®¹ã§ æ–°è¦Gistã‚’ä½œæˆ</button>
                            {gistId && (
                              <a href={`https://gist.github.com/${gistId}`} target="_blank" rel="noreferrer" className="text-xs text-blue-600 underline">
                                Gist ã‚’é–‹ã
                              </a>
                            )}
                          </div>

                          {/* Actions */}
                          <div className="flex items-center justify-between pt-2">
                            <div className="flex gap-2">
                              <button onClick={doPull} className="px-3 py-2 text-sm bg-gray-100 rounded hover:bg-gray-200">Pullï¼ˆèª­ã¿è¾¼ã¿ï¼‰</button>
                              <button onClick={doPush} className="px-3 py-2 text-sm bg-gray-900 text-white rounded hover:bg-gray-800">Pushï¼ˆä¿å­˜ï¼‰</button>
                            </div>
                            <label className="flex items-center gap-2 text-xs">
                              <input type="checkbox" checked={autoPush} onChange={toggleAutoPush}/>
                              è‡ªå‹•Push
                            </label>
                          </div>

                          <div className="flex justify-end">
                            <button onClick={unlinkGist} className="text-xs text-red-600 hover:underline">Gist ãƒªãƒ³ã‚¯è§£é™¤</button>
                          </div>
                        </div>
                      )}
                    </div>
                  )}
                </div>
              </div>
            </div>

            {selectedItem ? (
              <>
                {selectedItem.type==='note' ? (
                  <div className="flex-1 p-4 space-y-4 overflow-auto">
                    {/* æœ¬æ–‡ï¼ˆè‡ªå‹•ãƒªã‚µã‚¤ã‚ºï¼‰ */}
                    <div className="bg-white border rounded-xl">
                      <div className="px-3 py-2 text-xs text-gray-500 border-b bg-gray-50 rounded-t-xl">æœ¬æ–‡</div>
                      <textarea
                        ref={noteTextareaRef}
                        value={selectedItem.content || ''}
                        onChange={(e)=>handleContentChange(e.target.value)}
                        placeholder="ã“ã“ã«ãƒ¡ãƒ¢ã‚’æ›¸ã„ã¦ãã ã•ã„..."
                        className="w-full min-h-[3rem] p-4 border-0 focus:outline-none rounded-b-xl resize-none overflow-hidden"
                        disabled={readOnlyMode}
                      />
                    </div>

                    {/* ãƒ–ãƒ­ãƒƒã‚¯ */}
                    <div>
                      <div className="px-1 pb-2 text-xs text-gray-500">ãƒ–ãƒ­ãƒƒã‚¯</div>
                      {(selectedItem.blocks && selectedItem.blocks.length > 0) ? (
                        selectedItem.blocks.map(b => b.type==='table' ? <TableBlock key={b.id} block={b}/> : null)
                      ) : (
                        <div className="text-sm text-gray-500">ãƒ–ãƒ­ãƒƒã‚¯ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚{!readOnlyMode && 'ã€Œãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è¿½åŠ ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚'}</div>
                      )}
                    </div>
                  </div>
                ) : (
                  <div className="flex-1 flex items-center justify-center text-gray-500">
                    <div className="text-center">
                      <Folder size={48} className="mx-auto mb-4 text-gray-400"/>
                      <p>ãƒ•ã‚©ãƒ«ãƒ€ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã™</p>
                      <p className="text-sm">ãƒ¡ãƒ¢ã‚’é¸æŠã—ã¦ç·¨é›†ã—ã¦ãã ã•ã„</p>
                    </div>
                  </div>
                )}
              </>
            ) : (
              <div className="flex-1 flex items-center justify-center text-gray-500">
                <div className="text-center">
                  <FileText size={48} className="mx-auto mb-4 text-gray-400"/>
                  <p>ãƒ¡ãƒ¢ã¾ãŸã¯ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠã—ã¦ãã ã•ã„</p>
                  <p className="text-sm">å·¦å´ã®ã‚µã‚¤ãƒ‰ãƒãƒ¼ã‹ã‚‰ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„</p>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    };

    ReactDOM.render(<HierarchicalNotepad/>, document.getElementById('root'));
  </script>
</body>
</html>
